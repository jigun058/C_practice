#include<stdio.h>
#include<stdlib.h>

typedef int element;

typedef struct TreeNode
{
   element key;
   struct TreeNode *left, *right, *parent;
}TreeNode;

TreeNode* makeNode(element key)
{
   TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
   node->key = key;
   node->left = node->right = node->parent = NULL;
   
   return node;
}


TreeNode* insertNode(TreeNode* root, element key)  //반복문을 이용한 이진탐색 트리 (parent 사용) 
{
   TreeNode* y = NULL;
   TreeNode* x = root;
   TreeNode* z = makeNode(key);
   
   
   while(x != NULL)
   {
      y = x;
      if(z->key < x->key)
         x = x->left;
      else
         x = x->right;
   }
   
   z->parent = y;
   
   if(y == NULL)  // z가 root라는 거임. 
      root = z;
   else if(z->key < y->key)
      y->left = z;
   else
      y->right = z;
   
   return root; 
}

//서치 노드  
TreeNode* searchNode(TreeNode* root, element key) 
{
   if(root == NULL || key == root->key){
      return root;
   }
   
   if(key < root->key)
      return searchNode(root->left, key);
   else
      return searchNode(root->right, key);
   
}


// 키값이 가장 작은 노드 찾기  
TreeNode* minNode(TreeNode* root)
{
   TreeNode* p = root;
   
   while(p->left != NULL)
      p = p->left;
   
   return p;
}

//키값이 가장 큰 노드 찾기  
TreeNode* maxNode(TreeNode* root)
{
   TreeNode* p = root;
   
   while(p->right != NULL)
      p = p->right;
   
   return p;
}

//후계자 노드 찾기  
TreeNode* successor(TreeNode* root)          
{
   TreeNode* x = root; 
   if(x->right != NULL)    //오른쪽 자식 노드가 없으면, 어차피 왼쪽 자식 노드가 후계자가 되니까 이 부분이  하는 일은 없다. 
      return minNode(x->right);
      
   TreeNode* y = x->parent;
   while(y != NULL && x == y->right)
   {
      x = y;
      y = y->parent;   
   }
   return y;
}



TreeNode* deleteNode(TreeNode* root, element key)    //삭제 연산  
{
    TreeNode*x,*y;
    TreeNode*z=searchNode(root,key);
    
   if(z->left ==NULL||z->right==NULL){
       y=z;
   }else{
       y=successor(z);
   }
   if(y->left!=NULL){
       x=y->left;
   }else{
       x=y->right;
   }
   
   if(x!=NULL){
       x->parent;
   }
   
   if(y->parent==NULL){
       root=x;
   }else if(y==y->parent->left){
       y->parent->left=x;
   }else{
       y->parent->right=x;
   }
   
   if(y!=z){
       z->key=y->key;
   }
   
   return root;   
}

void inOrder(TreeNode* root){
   if(root != NULL)
   {
      inOrder(root->left);
      printf("[%d] ", root->key);
      inOrder(root->right);
   }
}

int main(){
   TreeNode* root = NULL;
   element keys[] = {35, 18, 7, 26, 12, 3, 68, 22, 30, 99};
   
   for(int i = 0; i < 10; i++){
      root = insertNode(root, keys[i]);
      inOrder(root);
      printf("\n");
   }
   printf("\n");
   
   printf("Successor : %d\n", successor(searchNode(root, 26))->key); // successor 함수 확인용 코드 
   
   //(searchNode(root, 22) != NULL) ? printf("Found\n") : printf("Not Found\n");    //서치 함수 작동 확인용 코드 
   
   root = deleteNode(root,35); inOrder(root); printf("\n");
   //root = deleteNode(root,30); inOrder(root); printf("\n");
   //root = deleteNode(root,26); inOrder(root); printf("\n");
}


//힙트리 , 힙 정렬 구현해보기  
